<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 手势交互粒子系统</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* 摄像头预览 (左下角，小窗) */
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            transform: scaleX(-1); /* 镜像翻转 */
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        /* UI 面板 */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 20;
            transition: all 0.3s ease;
        }

        .btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn:hover { background: rgba(255, 255, 255, 0.2); transform: translateY(-2px); }
        .btn.active { background: #00d2ff; border-color: #00d2ff; text-shadow: 0 0 5px rgba(0,0,0,0.5); }

        /* 全屏按钮 */
        #fs-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }
        
        /* 加载提示 */
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00d2ff;
            font-size: 24px;
            pointer-events: none;
            text-align: center;
        }
    </style>
    
    <!-- 引入库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">正在初始化视觉模型...<br><span style="font-size:14px; color:#aaa;">请允许摄像头权限</span></div>

    <!-- UI -->
    <div id="ui-panel">
        <button class="btn active" onclick="setShape('heart')">爱心</button>
        <button class="btn" onclick="setShape('flower')">花朵</button>
        <button class="btn" onclick="setShape('saturn')">土星</button>
        <button class="btn" onclick="setShape('buddha')">佛像(意象)</button>
        <button class="btn" onclick="setShape('fireworks')">烟花</button>
    </div>

    <button id="fs-btn" onclick="toggleFullScreen()">⛶</button>

    <div id="video-container">
        <video class="input_video"></video>
    </div>

<script>
    // --- 1. Three.js 初始化 ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.002);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- 2. 粒子系统核心 ---
    const particleCount = 15000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const targetPositions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);

    const color1 = new THREE.Color(0x00d2ff); // 青色
    const color2 = new THREE.Color(0xff007f); // 洋红

    for (let i = 0; i < particleCount; i++) {
        // 初始位置：随机分布
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

        // 初始颜色
        colors[i * 3] = color1.r;
        colors[i * 3 + 1] = color1.g;
        colors[i * 3 + 2] = color1.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // 着色器材质让粒子更好看
    const material = new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. 形状生成逻辑 ---
    let currentShape = 'heart';

    function getPointOnHeart(t) {
        // 心形参数方程
        let x = 16 * Math.pow(Math.sin(t), 3);
        let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        return { x: x * 0.5, y: y * 0.5 };
    }

    function calculateTargets(shape) {
        const scale = 1;
        
        for (let i = 0; i < particleCount; i++) {
            let x, y, z;
            const i3 = i * 3;

            if (shape === 'heart') {
                // 3D 心形
                const t = Math.random() * Math.PI * 2;
                const p = getPointOnHeart(t);
                // 增加厚度
                const zDist = (Math.random() - 0.5) * 5;
                x = p.x;
                y = p.y;
                z = zDist;
            } 
            else if (shape === 'saturn') {
                const r = Math.random();
                if (r < 0.6) {
                    // 星球本体
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const rad = 6;
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    y = rad * Math.sin(phi) * Math.sin(theta);
                    z = rad * Math.cos(phi);
                } else {
                    // 光环
                    const theta = Math.random() * Math.PI * 2;
                    const rad = 8 + Math.random() * 6;
                    x = rad * Math.cos(theta);
                    z = rad * Math.sin(theta);
                    y = (Math.random() - 0.5) * 0.5; // 薄薄一层
                    
                    // 倾斜光环
                    const tilt = 0.4;
                    const tempY = y * Math.cos(tilt) - z * Math.sin(tilt);
                    const tempZ = y * Math.sin(tilt) + z * Math.cos(tilt);
                    y = tempY;
                    z = tempZ;
                }
            } 
            else if (shape === 'flower') {
                // 玫瑰曲线
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const k = 4; // 花瓣数
                const r = 8 * Math.cos(k * theta);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.cos(phi); // 稍作变形
                z = r * Math.sin(phi) * Math.sin(theta);
            }
            else if (shape === 'buddha') {
                // 程序化生成“打坐者”意象 (无需加载外部模型)
                const r = Math.random();
                if (r < 0.2) { 
                    // 头部 (球体)
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const rad = 2.5;
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    y = rad * Math.sin(phi) * Math.sin(theta) + 6;
                    z = rad * Math.cos(phi);
                } else if (r < 0.6) {
                    // 身体 (椭球)
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = 4.5 * Math.sin(phi) * Math.cos(theta);
                    y = 5 * Math.sin(phi) * Math.sin(theta);
                    z = 3 * Math.cos(phi);
                } else {
                    // 盘腿底座 (扁圆)
                    const theta = Math.random() * Math.PI * 2;
                    const rad = 7 * Math.sqrt(Math.random()); 
                    x = rad * Math.cos(theta);
                    z = rad * Math.sin(theta);
                    y = -4 + (Math.random() * 2);
                }
            }
            else if (shape === 'fireworks') {
                // 随机炸开
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const rad = Math.random() * 25; // 扩散大
                x = rad * Math.sin(phi) * Math.cos(theta);
                y = rad * Math.sin(phi) * Math.sin(theta);
                z = rad * Math.cos(phi);
            }

            targetPositions[i3] = x;
            targetPositions[i3 + 1] = y;
            targetPositions[i3 + 2] = z;
        }
    }

    // 初始计算
    calculateTargets('heart');

    // UI 切换
    window.setShape = (shapeName) => {
        currentShape = shapeName;
        calculateTargets(shapeName);
        
        // 更新按钮样式
        document.querySelectorAll('.btn').forEach(btn => btn.classList.remove('active'));
        event.target.classList.add('active');
    };

    // --- 4. 手势控制逻辑 ---
    let handPinched = false;
    let pinchDistance = 1.0; // 0 (捏紧) 到 1 (张开)
    let handX = 0;
    let handY = 0;

    const videoElement = document.getElementsByClassName('input_video')[0];

    function onResults(results) {
        document.getElementById('loading').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // 关键点：4 (大拇指尖), 8 (食指尖)
            const thumb = landmarks[4];
            const index = landmarks[8];
            const wrist = landmarks[0];

            // 计算欧几里得距离
            const distance = Math.sqrt(
                Math.pow(thumb.x - index.x, 2) + 
                Math.pow(thumb.y - index.y, 2)
            );

            // 映射距离到 0~1 之间 (根据摄像头实际体验调整阈值)
            // 通常 0.02 是捏合, 0.2 是张开
            let normalized = (distance - 0.02) / (0.15 - 0.02);
            normalized = Math.max(0, Math.min(1, normalized));
            
            pinchDistance = normalized; // 1 = 张开 (扩散), 0 = 捏合 (凝聚)
            
            // 记录手的位置用于旋转场景
            handX = (wrist.x - 0.5) * 2; // -1 to 1
            handY = (wrist.y - 0.5) * 2;
        } else {
            // 如果没检测到手，默认缓慢恢复到凝聚状态
            pinchDistance = 0.1; // 默认凝聚显示模型
            handX *= 0.95; 
            handY *= 0.95;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    cameraUtils.start();


    // --- 5. 动画循环 ---
    let time = 0;

    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        const positionsArray = particles.geometry.attributes.position.array;
        
        // 手势交互参数
        // pinchDistance: 1 (张开/扩散), 0 (捏合/形状)
        // 我们希望：捏合时(0) -> 紧贴目标形状；张开时(1) -> 爆炸/扩散
        
        // 动态调整扩散力度
        const explosionFactor = pinchDistance * 30; // 扩散倍率
        const randomness = pinchDistance * 0.5; // 抖动幅度

        // 场景根据手的位置微转
        particles.rotation.y += 0.002; // 自动旋转
        particles.rotation.x += (handY * 0.5 - particles.rotation.x) * 0.05;
        particles.rotation.y += (-handX * 0.5 - (particles.rotation.y % (Math.PI*2))) * 0.05;

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // 目标位置
            const tx = targetPositions[i3];
            const ty = targetPositions[i3 + 1];
            const tz = targetPositions[i3 + 2];

            // 当前位置
            let px = positionsArray[i3];
            let py = positionsArray[i3 + 1];
            let pz = positionsArray[i3 + 2];

            // 1. 形状 Lerp (让粒子飞向目标形状)
            // 速度系数
            const speed = 0.05; 
            px += (tx - px) * speed;
            py += (ty - py) * speed;
            pz += (tz - pz) * speed;

            // 2. 手势扩散效果
            // 如果手张开 (pinchDistance 接近 1)，加上沿原点向外的向量
            if (pinchDistance > 0.1) {
                // 简单的从中心炸开效果
                const dist = Math.sqrt(tx*tx + ty*ty + tz*tz) + 0.1;
                const dirX = tx / dist;
                const dirY = ty / dist;
                const dirZ = tz / dist;

                px += dirX * explosionFactor;
                py += dirY * explosionFactor;
                pz += dirZ * explosionFactor;
                
                // 加点噪点
                px += (Math.random()-0.5) * randomness;
                py += (Math.random()-0.5) * randomness;
                pz += (Math.random()-0.5) * randomness;
            }

            // 3. 呼吸/漂浮特效 (让粒子即使静止也动起来)
            if (pinchDistance < 0.2 && currentShape !== 'fireworks') {
                px += Math.sin(time + i) * 0.02;
                py += Math.cos(time + i * 0.5) * 0.02;
            }

            positionsArray[i3] = px;
            positionsArray[i3 + 1] = py;
            positionsArray[i3 + 2] = pz;
        }

        particles.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    animate();

    // --- 6. 工具函数 ---
    window.toggleFullScreen = () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    };

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>